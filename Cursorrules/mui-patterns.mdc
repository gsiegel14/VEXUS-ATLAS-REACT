---
description: 
globs: 
alwaysApply: true
---
# Material-UI Component Patterns (.mdc)

## CRITICAL MUI DEVELOPMENT RULES - ENFORCE ALL 7 CORE TENETS

### ðŸŽ¨ MUI THEMING & CONFIGURATION REQUIREMENTS
- âœ… All colors, spacing, and breakpoints must be from theme
- âœ… No hardcoded CSS values allowed
- âœ… Must use sx prop for styling, not CSS-in-JS
- âœ… Theme must be configuration-driven and editable

### ðŸ“± MUI RESPONSIVE DESIGN REQUIREMENTS
- âœ… Must use MUI breakpoint system exclusively
- âœ… All layouts must be mobile-first
- âœ… Components must adapt to all screen sizes
- âœ… Touch targets must be 44px minimum

### â™¿ MUI ACCESSIBILITY REQUIREMENTS  
- âœ… All interactive elements must have ARIA labels
- âœ… Keyboard navigation must be fully supported
- âœ… Color contrast must meet WCAG 2.1 AA standards
- âœ… Screen reader support must be comprehensive

### âš¡ MUI PERFORMANCE REQUIREMENTS
- âœ… Must use React.memo for expensive components
- âœ… Must lazy load large components
- âœ… Must virtualize long lists
- âœ… Bundle size impact must be minimized

---

## MANDATORY MUI THEME CONFIGURATION

```jsx
// src/theme/vexusTheme.js

import { createTheme } from '@mui/material/styles';
import { logger } from '../utils/logger';

// REQUIRED: All theme values must be configurable (RULE 2)
const themeConfig = {
  palette: {
    primary: {
      main: '#43c3ac',
      light: '#6fd5bd',
      dark: '#2e8a73',
      contrastText: '#ffffff'
    },
    secondary: {
      main: '#f9f9f9',
      light: '#ffffff',
      dark: '#e0e0e0',
      contrastText: '#333333'
    },
    error: {
      main: '#d32f2f',
      light: '#ef5350',
      dark: '#c62828'
    },
    warning: {
      main: '#ff9800',
      light: '#ffb74d',
      dark: '#f57c00'
    },
    success: {
      main: '#2e7d32',
      light: '#4caf50',
      dark: '#1b5e20'
    },
    background: {
      default: '#fafafa',
      paper: '#ffffff'
    }
  },
  typography: {
    fontFamily: '"proxima-nova", "Helvetica Neue", Helvetica, Arial, sans-serif',
    h1: {
      fontSize: '2.5rem',
      fontWeight: 'bold',
      lineHeight: 1.2
    },
    h2: {
      fontSize: '2.125rem',
      fontWeight: 'bold',
      lineHeight: 1.3
    },
    h3: {
      fontSize: '1.75rem',
      fontWeight: 'bold',
      lineHeight: 1.4
    },
    body1: {
      fontSize: '1rem',
      lineHeight: 1.6
    },
    body2: {
      fontSize: '0.875rem',
      lineHeight: 1.6
    }
  },
  spacing: 8,
  breakpoints: {
    values: {
      xs: 0,
      sm: 600,
      md: 768,
      lg: 980,
      xl: 1200
    }
  },
  shape: {
    borderRadius: 8
  },
  transitions: {
    duration: {
      shortest: 150,
      shorter: 200,
      short: 250,
      standard: 300,
      complex: 375,
      enteringScreen: 225,
      leavingScreen: 195
    }
  }
};

// REQUIRED: Theme creation with logging (RULE 4)
export const createVexusTheme = () => {
  logger.info('Theme: Creating VEXUS theme', { 
    primaryColor: themeConfig.palette.primary.main,
    breakpoints: themeConfig.breakpoints.values
  });

  const theme = createTheme(themeConfig);
  
  // REQUIRED: Enhanced theme with custom properties (RULE 2)
  theme.custom = {
    layout: {
      maxWidth: 'xl',
      padding: { xs: 2, md: 4 },
      borderRadius: 1,
      elevation: 2
    },
    animations: {
      duration: theme.transitions.duration.standard,
      easing: theme.transitions.easing.easeInOut
    },
    accessibility: {
      focusVisible: '2px solid ' + theme.palette.primary.main,
      touchTarget: 44
    }
  };

  return theme;
};

export const vexusTheme = createVexusTheme();
```

---

## MANDATORY MUI LAYOUT PATTERNS

### 1. Responsive Container Pattern

```jsx
// REQUIRED: All containers must be responsive and themeable (RULE 2 & 4)
import { Container, useTheme, useMediaQuery } from '@mui/material';
import { logger } from '../utils/logger';

const ResponsiveContainer = ({ children, maxWidth = 'lg', ...props }) => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  
  // REQUIRED: Log responsive state changes (RULE 4)
  React.useEffect(() => {
    logger.debug('ResponsiveContainer: Viewport change', { 
      isMobile, 
      maxWidth,
      viewportWidth: window.innerWidth 
    });
  }, [isMobile, maxWidth]);

  return (
    <Container
      maxWidth={maxWidth}
      sx={{
        py: theme.custom.layout.padding,
        px: { xs: 2, sm: 3, md: 4 },
        // REQUIRED: All spacing from theme (RULE 2)
        minHeight: '100vh',
        display: 'flex',
        flexDirection: 'column'
      }}
      {...props}
    >
      {children}
    </Container>
  );
};
```

### 2. Card Pattern with Error Handling

```jsx
// REQUIRED: All cards must include error boundaries and accessibility (RULE 5 & 6)
import { Card, CardContent, CardHeader, IconButton, Collapse } from '@mui/material';
import { ExpandMore, Error } from '@mui/icons-material';
import ErrorBoundary from '../common/ErrorBoundary/ErrorBoundary';

const VexusCard = ({ 
  title, 
  children, 
  expandable = false, 
  error = null,
  onError,
  ...props 
}) => {
  const [expanded, setExpanded] = useState(false);
  const theme = useTheme();

  // REQUIRED: Performance monitoring (RULE 6)
  const { measureFunction } = usePerformanceMonitor('VexusCard');

  const handleExpandClick = measureFunction('handleExpandClick', () => {
    logger.debug('VexusCard: Expand toggled', { title, expanded: !expanded });
    setExpanded(!expanded);
  });

  return (
    <ErrorBoundary onError={onError}>
      <Card
        elevation={theme.custom.layout.elevation}
        sx={{
          borderRadius: theme.custom.layout.borderRadius,
          transition: `all ${theme.custom.animations.duration}ms ${theme.custom.animations.easing}`,
          '&:hover': {
            elevation: theme.custom.layout.elevation + 2,
            transform: 'translateY(-2px)'
          },
          // REQUIRED: Accessibility focus visible (RULE 6)
          '&:focus-visible': {
            outline: theme.custom.accessibility.focusVisible
          }
        }}
        {...props}
      >
        <CardHeader
          title={title}
          action={
            expandable && (
              <IconButton
                onClick={handleExpandClick}
                aria-expanded={expanded}
                aria-label="show more"
                sx={{
                  transform: expanded ? 'rotate(180deg)' : 'rotate(0deg)',
                  transition: theme.transitions.create('transform', {
                    duration: theme.transitions.duration.shortest
                  })
                }}
              >
                <ExpandMore />
              </IconButton>
            )
          }
        />
        
        {/* REQUIRED: Error display (RULE 5) */}
        {error && (
          <CardContent sx={{ pt: 0 }}>
            <Alert severity="error" icon={<Error />}>
              {error.message || 'An error occurred'}
            </Alert>
          </CardContent>
        )}

        <Collapse in={!expandable || expanded} timeout="auto" unmountOnExit>
          <CardContent>{children}</CardContent>
        </Collapse>
      </Card>
    </ErrorBoundary>
  );
};
```

### 3. Form Pattern with Validation

```jsx
// REQUIRED: All forms must include comprehensive validation and error handling (RULE 5)
import { useForm, Controller } from 'react-hook-form';
import { TextField, Button, Box, Alert } from '@mui/material';
import { LoadingButton } from '@mui/lab';

const VexusForm = ({ 
  onSubmit, 
  onError, 
  fields, 
  submitLabel = 'Submit',
  ...props 
}) => {
  const theme = useTheme();
  const { measureFunction } = usePerformanceMonitor('VexusForm');
  const { errors, addError, removeError } = useErrorHandler();
  
  const { control, handleSubmit, formState: { isSubmitting, errors: formErrors } } = useForm();

  // REQUIRED: Form submission with comprehensive logging (RULE 4)
  const handleFormSubmit = measureFunction('handleFormSubmit', async (data) => {
    const formId = Math.random().toString(36).substr(2, 9);
    
    try {
      logger.info(`VexusForm: Form submission started [${formId}]`, { 
        fields: Object.keys(data),
        timestamp: new Date().toISOString()
      });

      clearErrors();
      
      // REQUIRED: Form validation (RULE 5)
      for (const field of fields) {
        if (field.required && (!data[field.name] || data[field.name].toString().trim() === '')) {
          throw new ValidationError(field.name, data[field.name], `${field.label} is required`);
        }
      }

      const result = await onSubmit(data);
      
      logger.info(`VexusForm: Form submission completed [${formId}]`, { 
        result: result?.id || 'success'
      });

    } catch (error) {
      logger.error(`VexusForm: Form submission failed [${formId}]`, {
        error: error.message,
        formData: Object.keys(data),
        stack: error.stack
      });
      
      addError(error);
      
      if (onError) {
        onError(error);
      }
    }
  });

  return (
    <Box component="form" onSubmit={handleSubmit(handleFormSubmit)} {...props}>
      {/* REQUIRED: Error display (RULE 5 & 7) */}
      <ErrorDisplay errors={errors} onDismiss={removeError} variant="inline" />
      
      {fields.map((field) => (
        <Controller
          key={field.name}
          name={field.name}
          control={control}
          rules={{
            required: field.required ? `${field.label} is required` : false,
            ...field.validation
          }}
          render={({ field: formField, fieldState: { error } }) => (
            <TextField
              {...formField}
              label={field.label}
              type={field.type || 'text'}
              fullWidth
              margin="normal"
              error={!!error}
              helperText={error?.message || field.helperText}
              disabled={isSubmitting}
              // REQUIRED: Accessibility attributes (RULE 6)
              aria-describedby={error ? `${field.name}-error` : undefined}
              sx={{
                // REQUIRED: Theme-based styling (RULE 2)
                '& .MuiOutlinedInput-root': {
                  borderRadius: theme.shape.borderRadius
                }
              }}
            />
          )}
        />
      ))}

      <LoadingButton
        type="submit"
        variant="contained"
        loading={isSubmitting}
        loadingPosition="start"
        fullWidth
        size="large"
        sx={{ 
          mt: 3, 
          mb: 2,
          // REQUIRED: Touch target size (RULE 6)
          minHeight: theme.custom.accessibility.touchTarget
        }}
      >
        {submitLabel}
      </LoadingButton>
    </Box>
  );
};
```

### 4. Data Display Pattern with Virtualization

```jsx
// REQUIRED: Large data sets must be virtualized for performance (RULE 6)
import { FixedSizeList as List } from 'react-window';
import { 
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow,
  Paper,
  Typography,
  Box
} from '@mui/material';

const VirtualizedTable = ({ 
  data, 
  columns, 
  rowHeight = 48, 
  maxHeight = 400,
  onRowClick,
  ...props 
}) => {
  const theme = useTheme();
  const { measureFunction } = usePerformanceMonitor('VirtualizedTable');

  // REQUIRED: Row click handling with logging (RULE 4)
  const handleRowClick = measureFunction('handleRowClick', (index, rowData) => {
    logger.debug('VirtualizedTable: Row clicked', { 
      index, 
      rowId: rowData.id,
      timestamp: new Date().toISOString()
    });
    
    if (onRowClick) {
      onRowClick(rowData, index);
    }
  });

  const Row = ({ index, style }) => {
    const rowData = data[index];
    
    return (
      <div style={style}>
        <TableRow
          hover
          onClick={() => handleRowClick(index, rowData)}
          sx={{
            cursor: onRowClick ? 'pointer' : 'default',
            // REQUIRED: Accessibility focus (RULE 6)
            '&:focus-visible': {
              outline: theme.custom.accessibility.focusVisible
            }
          }}
          tabIndex={onRowClick ? 0 : -1}
          role={onRowClick ? 'button' : undefined}
          aria-label={onRowClick ? `Select row ${index + 1}` : undefined}
        >
          {columns.map((column) => (
            <TableCell key={column.field}>
              {column.render ? column.render(rowData[column.field], rowData) : rowData[column.field]}
            </TableCell>
          ))}
        </TableRow>
      </div>
    );
  };

  return (
    <TableContainer component={Paper} {...props}>
      <Table stickyHeader>
        <TableHead>
          <TableRow>
            {columns.map((column) => (
              <TableCell key={column.field}>
                <Typography variant="subtitle2" sx={{ fontWeight: 'bold' }}>
                  {column.label}
                </Typography>
              </TableCell>
            ))}
          </TableRow>
        </TableHead>
      </Table>
      
      <Box sx={{ maxHeight }}>
        <List
          height={Math.min(maxHeight, data.length * rowHeight)}
          itemCount={data.length}
          itemSize={rowHeight}
          itemData={data}
        >
          {Row}
        </List>
      </Box>
    </TableContainer>
  );
};
```

### 5. Navigation Pattern with Analytics

```jsx
// REQUIRED: All navigation must be tracked and accessible (RULE 4 & 6)
import { AppBar, Toolbar, IconButton, Typography, Menu, MenuItem } from '@mui/material';
import { Menu as MenuIcon, AccountCircle } from '@mui/icons-material';
import { useNavigate, useLocation } from 'react-router-dom';

const VexusNavigation = ({ menuItems, user, onLogout }) => {
  const theme = useTheme();
  const navigate = useNavigate();
  const location = useLocation();
  const { measureFunction } = usePerformanceMonitor('VexusNavigation');
  
  const [anchorEl, setAnchorEl] = useState(null);

  // REQUIRED: Navigation tracking (RULE 4)
  const handleNavigation = measureFunction('handleNavigation', (path, label) => {
    logger.info('VexusNavigation: Navigation event', {
      from: location.pathname,
      to: path,
      label,
      timestamp: new Date().toISOString(),
      sessionId: sessionStorage.getItem('vexus_session_id')
    });
    
    navigate(path);
    setAnchorEl(null);
  });

  return (
    <AppBar 
      position="sticky" 
      elevation={theme.custom.layout.elevation}
      sx={{
        // REQUIRED: Theme-based colors (RULE 2)
        backgroundColor: theme.palette.primary.main
      }}
    >
      <Toolbar>
        <IconButton
          edge="start"
          color="inherit"
          aria-label="menu"
          onClick={(e) => setAnchorEl(e.currentTarget)}
          sx={{
            // REQUIRED: Touch target size (RULE 6)
            minWidth: theme.custom.accessibility.touchTarget,
            minHeight: theme.custom.accessibility.touchTarget
          }}
        >
          <MenuIcon />
        </IconButton>

        <Typography 
          variant="h6" 
          component="div" 
          sx={{ flexGrow: 1, ml: 2 }}
        >
          VEXUS ATLAS
        </Typography>

        {/* REQUIRED: Accessible menu with keyboard navigation (RULE 6) */}
        <Menu
          anchorEl={anchorEl}
          open={Boolean(anchorEl)}
          onClose={() => setAnchorEl(null)}
          MenuListProps={{
            'aria-labelledby': 'navigation-menu',
            role: 'menu'
          }}
        >
          {menuItems.map((item) => (
            <MenuItem
              key={item.path}
              onClick={() => handleNavigation(item.path, item.label)}
              selected={location.pathname === item.path}
              role="menuitem"
              sx={{
                // REQUIRED: Theme-based selection color (RULE 2)
                '&.Mui-selected': {
                  backgroundColor: theme.palette.primary.light + '20'
                }
              }}
            >
              {item.icon && <Box sx={{ mr: 2 }}>{item.icon}</Box>}
              {item.label}
            </MenuItem>
          ))}
        </Menu>
      </Toolbar>
    </AppBar>
  );
};
```

### 6. Modal Pattern with Focus Management

```jsx
// REQUIRED: All modals must manage focus and be fully accessible (RULE 6)
import { Dialog, DialogTitle, DialogContent, DialogActions, IconButton } from '@mui/material';
import { Close } from '@mui/icons-material';

const VexusModal = ({ 
  open, 
  onClose, 
  title, 
  children, 
  actions,
  maxWidth = 'md',
  ...props 
}) => {
  const theme = useTheme();
  const { measureFunction } = usePerformanceMonitor('VexusModal');

  // REQUIRED: Modal events must be logged (RULE 4)
  const handleClose = measureFunction('handleClose', (reason) => {
    logger.debug('VexusModal: Close event', { 
      title, 
      reason,
      timestamp: new Date().toISOString()
    });
    
    onClose(reason);
  });

  // REQUIRED: Escape key handling (RULE 6)
  React.useEffect(() => {
    const handleEscape = (event) => {
      if (event.key === 'Escape' && open) {
        handleClose('escapeKeyDown');
      }
    };

    document.addEventListener('keydown', handleEscape);
    return () => document.removeEventListener('keydown', handleEscape);
  }, [open, handleClose]);

  return (
    <Dialog
      open={open}
      onClose={(event, reason) => handleClose(reason)}
      maxWidth={maxWidth}
      fullWidth
      // REQUIRED: Accessibility attributes (RULE 6)
      aria-labelledby="modal-title"
      aria-describedby="modal-description"
      // REQUIRED: Focus management (RULE 6)
      disableRestoreFocus={false}
      keepMounted={false}
      sx={{
        '& .MuiDialog-paper': {
          borderRadius: theme.shape.borderRadius * 2,
          // REQUIRED: Theme-based spacing (RULE 2)
          m: theme.spacing(2)
        }
      }}
      {...props}
    >
      <DialogTitle id="modal-title" sx={{ pr: 6 }}>
        {title}
        
        {/* REQUIRED: Close button with accessibility (RULE 6) */}
        <IconButton
          aria-label="close"
          onClick={() => handleClose('closeButton')}
          sx={{
            position: 'absolute',
            right: theme.spacing(1),
            top: theme.spacing(1),
            color: theme.palette.grey[500]
          }}
        >
          <Close />
        </IconButton>
      </DialogTitle>

      <DialogContent id="modal-description">
        {children}
      </DialogContent>

      {actions && (
        <DialogActions sx={{ p: theme.spacing(2) }}>
          {actions}
        </DialogActions>
      )}
    </Dialog>
  );
};
```

---

## MANDATORY MUI PERFORMANCE PATTERNS

### 1. Memoized Component Pattern

```jsx
// REQUIRED: Expensive components must be memoized (RULE 6)
import React, { memo } from 'react';

const ExpensiveComponent = memo(({ data, onAction }) => {
  const { measureFunction } = usePerformanceMonitor('ExpensiveComponent');
  
  // REQUIRED: Expensive operations must be measured (RULE 6)
  const processedData = useMemo(measureFunction('processData', () => {
    logger.debug('ExpensiveComponent: Processing data', { 
      itemCount: data?.length || 0 
    });
    
    return data?.map(item => ({
      ...item,
      processed: true,
      timestamp: Date.now()
    })) || [];
  }), [data, measureFunction]);

  return (
    <Box>
      {/* Expensive rendering logic */}
    </Box>
  );
}, (prevProps, nextProps) => {
  // REQUIRED: Custom comparison with logging (RULE 6)
  const shouldUpdate = (
    prevProps.data !== nextProps.data ||
    prevProps.onAction !== nextProps.onAction
  );
  
  if (!shouldUpdate) {
    logger.debug('ExpensiveComponent: Render skipped due to memoization');
  }
  
  return !shouldUpdate;
});
```

### 2. Lazy Loading Pattern

```jsx
// REQUIRED: Large components must be lazy loaded (RULE 6)
import { lazy, Suspense } from 'react';
import { CircularProgress, Box } from '@mui/material';

// REQUIRED: Lazy load with error boundary (RULE 5 & 6)
const LazyComponent = lazy(() => 
  import('./HeavyComponent').catch(error => {
    logger.error('LazyComponent: Failed to load', { error: error.message });
    return { default: () => <Alert severity="error">Failed to load component</Alert> };
  })
);

const LazyComponentWrapper = (props) => {
  return (
    <ErrorBoundary>
      <Suspense
        fallback={
          <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
            <CircularProgress />
          </Box>
        }
      >
        <LazyComponent {...props} />
      </Suspense>
    </ErrorBoundary>
  );
};
```

---

## MUI DEVELOPMENT CHECKLIST - MANDATORY COMPLIANCE

### âœ… Theming & Configuration
- [ ] All styling uses theme values
- [ ] No hardcoded CSS values
- [ ] sx prop used instead of CSS-in-JS
- [ ] Theme is configuration-driven

### âœ… Responsive Design
- [ ] MUI breakpoint system used exclusively
- [ ] Mobile-first approach implemented
- [ ] All screen sizes supported
- [ ] Touch targets 44px minimum

### âœ… Accessibility
- [ ] ARIA labels on all interactive elements
- [ ] Keyboard navigation fully supported
- [ ] WCAG 2.1 AA color contrast met
- [ ] Screen reader compatibility verified

### âœ… Performance
- [ ] Expensive components memoized
- [ ] Large components lazy loaded
- [ ] Long lists virtualized
- [ ] Bundle size impact minimized

### âœ… Error Integration
- [ ] Error boundaries implemented
- [ ] Error states designed
- [ ] Recovery mechanisms provided
- [ ] User feedback comprehensive

### âœ… Logging Integration
- [ ] User interactions logged
- [ ] Performance metrics captured
- [ ] Error events tracked
- [ ] Debug information available

## FAILURE TO FOLLOW MUI PATTERNS WILL RESULT IN CODE REJECTION
