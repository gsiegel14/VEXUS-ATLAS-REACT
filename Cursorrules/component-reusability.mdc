---
description: 
globs: 
alwaysApply: true
---
# Component Reusability & Code Duplication Avoidance

## ðŸŽ¯ **REUSABILITY PRINCIPLES**

### **1. DRY (Don't Repeat Yourself) at Component Level**
If you write the same JSX pattern more than twice, extract it into a component.

### **2. Composition over Configuration**
Build flexible components that can be composed rather than configured with many props.

### **3. Single Responsibility Principle**
Each component should have one clear purpose and do it well.

### **4. Progressive Enhancement**
Start with basic components and add complexity through composition.

## ðŸ—ï¸ **COMPONENT HIERARCHY PATTERNS**

### **Pattern 1: Base â†’ Variant â†’ Specialized**

```typescript
// âŒ WRONG: Multiple similar components with duplicate code
const PrimaryButton = ({ children, onClick }) => (
  <MuiButton variant="contained" color="primary" onClick={onClick}>
    {children}
  </MuiButton>
);

const SecondaryButton = ({ children, onClick }) => (
  <MuiButton variant="outlined" color="secondary" onClick={onClick}>
    {children}
  </MuiButton>
);

const DangerButton = ({ children, onClick }) => (
  <MuiButton variant="contained" color="error" onClick={onClick}>
    {children}
  </MuiButton>
);

// âœ… CORRECT: Flexible base component with variants
interface ButtonProps {
  children: React.ReactNode;
  variant?: 'primary' | 'secondary' | 'outline' | 'danger';
  size?: 'small' | 'medium' | 'large';
  fullWidth?: boolean;
  disabled?: boolean;
  loading?: boolean;
  startIcon?: React.ReactNode;
  endIcon?: React.ReactNode;
  onClick?: () => void;
}

const Button: React.FC<ButtonProps> = ({
  children,
  variant = 'primary',
  size = 'medium',
  fullWidth = false,
  disabled = false,
  loading = false,
  startIcon,
  endIcon,
  onClick,
  ...rest
}) => {
  const getVariantProps = () => {
    switch (variant) {
      case 'primary':
        return { variant: 'contained' as const, color: 'primary' as const };
      case 'secondary':
        return { variant: 'contained' as const, color: 'secondary' as const };
      case 'outline':
        return { variant: 'outlined' as const, color: 'primary' as const };
      case 'danger':
        return { variant: 'contained' as const, color: 'error' as const };
      default:
        return { variant: 'contained' as const, color: 'primary' as const };
    }
  };

  return (
    <MuiButton
      {...getVariantProps()}
      size={size}
      fullWidth={fullWidth}
      disabled={disabled || loading}
      startIcon={loading ? <CircularProgress size={16} /> : startIcon}
      endIcon={endIcon}
      onClick={onClick}
      sx={{
        position: 'relative',
        '&:disabled': {
          cursor: loading ? 'wait' : 'not-allowed',
        },
      }}
      {...rest}
    >
      {children}
    </MuiButton>
  );
};

// Now use with variants:
<Button variant="primary">Save</Button>
<Button variant="outline" startIcon={<Add />}>Add Item</Button>
<Button variant="danger" loading={isDeleting}>Delete</Button>
```

### **Pattern 2: Compound Components**

```typescript
// âœ… Modal compound component pattern
interface ModalProps {
  open: boolean;
  onClose: () => void;
  children: React.ReactNode;
  maxWidth?: 'xs' | 'sm' | 'md' | 'lg' | 'xl';
}

const Modal: React.FC<ModalProps> & {
  Header: React.FC<ModalHeaderProps>;
  Body: React.FC<ModalBodyProps>;
  Footer: React.FC<ModalFooterProps>;
} = ({ open, onClose, children, maxWidth = 'md' }) => {
  return (
    <Dialog open={open} onClose={onClose} maxWidth={maxWidth} fullWidth>
      {children}
    </Dialog>
  );
};

const ModalHeader: React.FC<ModalHeaderProps> = ({ title, onClose, children }) => (
  <DialogTitle sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
    {title || children}
    {onClose && (
      <IconButton onClick={onClose} size="small">
        <Close />
      </IconButton>
    )}
  </DialogTitle>
);

const ModalBody: React.FC<ModalBodyProps> = ({ children, ...rest }) => (
  <DialogContent {...rest}>{children}</DialogContent>
);

const ModalFooter: React.FC<ModalFooterProps> = ({ 
  children, 
  justifyContent = 'flex-end',
  spacing = 2 
}) => (
  <DialogActions sx={{ justifyContent, gap: spacing }}>
    {children}
  </DialogActions>
);

// Attach sub-components
Modal.Header = ModalHeader;
Modal.Body = ModalBody;
Modal.Footer = ModalFooter;

// Usage - clean and readable:
<Modal open={isOpen} onClose={handleClose}>
  <Modal.Header title="Confirm Delete" onClose={handleClose} />
  <Modal.Body>
    <Typography>Are you sure you want to delete this item?</Typography>
  </Modal.Body>
  <Modal.Footer>
    <Button variant="outline" onClick={handleClose}>Cancel</Button>
    <Button variant="danger" onClick={handleDelete}>Delete</Button>
  </Modal.Footer>
</Modal>
```

## ðŸ”„ **LAYOUT REUSABILITY PATTERNS**

### **Pattern 3: Layout Composition System**

```typescript
// âœ… Flexible layout components that compose together

// Base layout component
interface PageLayoutProps {
  children: React.ReactNode;
  maxWidth?: 'xs' | 'sm' | 'md' | 'lg' | 'xl' | false;
  disableGutters?: boolean;
  sx?: SxProps<Theme>;
}

const PageLayout: React.FC<PageLayoutProps> = ({ 
  children, 
  maxWidth = 'lg', 
  disableGutters = false,
  sx 
}) => (
  <Container maxWidth={maxWidth} disableGutters={disableGutters} sx={{ py: 4, ...sx }}>
    {children}
  </Container>
);

// Section wrapper component
interface SectionProps {
  children: React.ReactNode;
  spacing?: number;
  bgcolor?: string;
  sx?: SxProps<Theme>;
}

const Section: React.FC<SectionProps> = ({ 
  children, 
  spacing = 6, 
  bgcolor,
  sx 
}) => (
  <Box 
    component="section" 
    sx={{ 
      py: spacing, 
      bgcolor,
      ...sx 
    }}
  >
    {children}
  </Box>
);

// Hero section component
interface HeroSectionProps {
  title: string;
  subtitle?: string;
  actions?: React.ReactNode;
  backgroundImage?: string;
  variant?: 'default' | 'centered' | 'left-aligned';
}

const HeroSection: React.FC<HeroSectionProps> = ({
  title,
  subtitle,
  actions,
  backgroundImage,
  variant = 'centered'
}) => (
  <Section
    spacing={8}
    sx={{
      backgroundImage: backgroundImage ? `url(${backgroundImage})` : undefined,
      backgroundSize: 'cover',
      backgroundPosition: 'center',
      textAlign: variant === 'left-aligned' ? 'left' : 'center',
    }}
  >
    <PageLayout>
      <Typography variant="h1" gutterBottom>{title}</Typography>
      {subtitle && (
        <Typography variant="h3" color="text.secondary" paragraph>
          {subtitle}
        </Typography>
      )}
      {actions && (
        <Box sx={{ mt: 4 }}>
          {actions}
        </Box>
      )}
    </PageLayout>
  </Section>
);

// Content section component
interface ContentSectionProps {
  title?: string;
  subtitle?: string;
  children: React.ReactNode;
  layout?: 'stack' | 'grid' | 'flex';
  spacing?: number;
}

const ContentSection: React.FC<ContentSectionProps> = ({
  title,
  subtitle,
  children,
  layout = 'stack',
  spacing = 3
}) => (
  <Section>
    <PageLayout>
      {(title || subtitle) && (
        <Box sx={{ mb: 4, textAlign: 'center' }}>
          {title && <Typography variant="h2" gutterBottom>{title}</Typography>}
          {subtitle && <Typography variant="h4" color="text.secondary">{subtitle}</Typography>}
        </Box>
      )}
      
      {layout === 'grid' ? (
        <Grid container spacing={spacing}>{children}</Grid>
      ) : layout === 'flex' ? (
        <Stack direction="row" spacing={spacing} flexWrap="wrap">{children}</Stack>
      ) : (
        <Stack spacing={spacing}>{children}</Stack>
      )}
    </PageLayout>
  </Section>
);

// Now pages become clean compositions:
const HomePage = () => (
  <MainLayout>
    <HeroSection 
      title="VEXUS ATLAS"
      subtitle="A Collaborative Ultrasound Education Platform"
      actions={
        <Button variant="primary" size="large">
          Explore Projects
        </Button>
      }
    />
    
    <ContentSection 
      title="Our Projects" 
      layout="grid"
    >
      <Grid item xs={12} sm={6} md={3}>
        <ProjectCard project={projects.atlas} />
      </Grid>
      <Grid item xs={12} sm={6} md={3}>
        <ProjectCard project={projects.evidence} />
      </Grid>
      {/* ... more items */}
    </ContentSection>
  </MainLayout>
);
```

## ðŸ“‹ **FORM REUSABILITY PATTERNS**

### **Pattern 4: Form Field Composition**

```typescript
// âœ… Reusable form field wrapper
interface FormFieldProps {
  label: string;
  name: string;
  required?: boolean;
  error?: string;
  helperText?: string;
  children: React.ReactElement;
}

const FormField: React.FC<FormFieldProps> = ({
  label,
  name,
  required,
  error,
  helperText,
  children
}) => (
  <Box sx={{ mb: 2 }}>
    <FormLabel htmlFor={name} required={required} sx={{ display: 'block', mb: 1 }}>
      {label}
    </FormLabel>
    {React.cloneElement(children, {
      id: name,
      name,
      error: Boolean(error),
      helperText: error || helperText,
    })}
  </Box>
);

// âœ… Specialized form components
const TextInput: React.FC<TextFieldProps> = (props) => (
  <TextField fullWidth variant="outlined" {...props} />
);

const SelectInput: React.FC<SelectProps> = ({ options, ...props }) => (
  <Select fullWidth {...props}>
    {options.map(option => (
      <MenuItem key={option.value} value={option.value}>
        {option.label}
      </MenuItem>
    ))}
  </Select>
);

// âœ… Form template for consistent structure
interface FormTemplateProps {
  title: string;
  children: React.ReactNode;
  actions: React.ReactNode;
  loading?: boolean;
}

const FormTemplate: React.FC<FormTemplateProps> = ({
  title,
  children,
  actions,
  loading = false
}) => (
  <Card sx={{ maxWidth: 600, mx: 'auto' }}>
    <CardHeader title={title} />
    <CardContent>
      <Stack spacing={3}>
        {children}
      </Stack>
    </CardContent>
    <CardActions sx={{ justifyContent: 'flex-end', p: 3 }}>
      {loading && <CircularProgress size={24} sx={{ mr: 2 }} />}
      {actions}
    </CardActions>
  </Card>
);

// Usage - consistent form structure:
const ContactForm = () => {
  const { register, handleSubmit, formState: { errors } } = useForm();

  return (
    <FormTemplate
      title="Contact Us"
      actions={
        <>
          <Button variant="outline">Cancel</Button>
          <Button variant="primary" type="submit">Send Message</Button>
        </>
      }
    >
      <FormField
        label="Your Name"
        name="name"
        required
        error={errors.name?.message}
      >
        <TextInput {...register('name', { required: 'Name is required' })} />
      </FormField>
      
      <FormField
        label="Email"
        name="email"
        required
        error={errors.email?.message}
      >
        <TextInput 
          type="email" 
          {...register('email', { 
            required: 'Email is required',
            pattern: {
              value: /^\S+@\S+$/i,
              message: 'Invalid email address'
            }
          })} 
        />
      </FormField>
      
      <FormField
        label="Subject"
        name="subject"
        required
        error={errors.subject?.message}
      >
        <SelectInput 
          options={[
            { value: 'general', label: 'General Inquiry' },
            { value: 'support', label: 'Technical Support' },
            { value: 'feedback', label: 'Feedback' }
          ]}
          {...register('subject', { required: 'Subject is required' })}
        />
      </FormField>
    </FormTemplate>
  );
};
```

## ðŸŽ¨ **STYLING REUSABILITY PATTERNS**

### **Pattern 5: Design System Tokens**

```typescript
// src/theme/designTokens.ts
export const designTokens = {
  spacing: {
    section: { xs: 4, md: 6, lg: 8 },
    component: { xs: 2, md: 3 },
    content: { xs: 3, md: 4 },
  },
  
  layout: {
    maxWidth: {
      content: 1200,
      text: 800,
      form: 600,
    },
    container: {
      padding: { xs: 2, sm: 3, md: 4 },
    },
  },
  
  elevation: {
    card: 1,
    modal: 8,
    tooltip: 16,
  },
  
  animation: {
    duration: {
      short: 150,
      standard: 300,
      long: 500,
    },
    easing: {
      standard: 'cubic-bezier(0.4, 0, 0.2, 1)',
      decelerate: 'cubic-bezier(0, 0, 0.2, 1)',
      accelerate: 'cubic-bezier(0.4, 0, 1, 1)',
    },
  },
} as const;

// src/theme/commonStyles.ts
export const commonStyles = {
  // Page layouts
  pageContainer: {
    py: designTokens.spacing.section,
    px: designTokens.layout.container.padding,
  },
  
  // Section styles
  heroSection: {
    textAlign: 'center' as const,
    py: { xs: 8, md: 12 },
    mb: designTokens.spacing.section,
  },
  
  contentSection: {
    py: designTokens.spacing.section,
    mb: designTokens.spacing.component,
  },
  
  // Component styles
  cardHover: {
    transition: `all ${designTokens.animation.duration.standard}ms ${designTokens.animation.easing.standard}`,
    '&:hover': {
      transform: 'translateY(-2px)',
      boxShadow: designTokens.elevation.modal,
    },
  },
  
  imageOverlay: {
    position: 'absolute' as const,
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    background: 'linear-gradient(45deg, rgba(0,0,0,0.3) 0%, rgba(0,0,0,0.1) 100%)',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    opacity: 0,
    transition: `opacity ${designTokens.animation.duration.standard}ms`,
    '&:hover': {
      opacity: 1,
    },
  },
  
  // Text styles
  truncateText: {
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap' as const,
  },
  
  multilineTruncate: (lines: number) => ({
    display: '-webkit-box',
    WebkitLineClamp: lines,
    WebkitBoxOrient: 'vertical' as const,
    overflow: 'hidden',
  }),
} as const;
```

### **Pattern 6: Responsive Utility Functions**

```typescript
// src/utils/responsive.ts
export const responsive = {
  // Responsive values helper
  value: <T>(xs: T, sm?: T, md?: T, lg?: T, xl?: T) => ({
    xs,
    ...(sm !== undefined && { sm }),
    ...(md !== undefined && { md }),
    ...(lg !== undefined && { lg }),
    ...(xl !== undefined && { xl }),
  }),
  
  // Common responsive patterns
  spacing: {
    section: responsive.value(4, 6, 8),
    component: responsive.value(2, 3, 4),
    tight: responsive.value(1, 2),
  },
  
  typography: {
    hero: responsive.value('2rem', '2.5rem', '3rem'),
    title: responsive.value('1.5rem', '1.75rem', '2rem'),
    body: responsive.value('0.875rem', '1rem'),
  },
  
  grid: {
    // Common grid breakpoints
    twoColumn: { xs: 12, md: 6 },
    threeColumn: { xs: 12, sm: 6, md: 4 },
    fourColumn: { xs: 12, sm: 6, md: 3 },
    sidebar: { xs: 12, md: 8 },
    aside: { xs: 12, md: 4 },
  },
};

// Usage in components:
const ProjectGrid = () => (
  <Grid container spacing={responsive.spacing.component}>
    {projects.map(project => (
      <Grid item {...responsive.grid.fourColumn} key={project.id}>
        <ProjectCard project={project} />
      </Grid>
    ))}
  </Grid>
);
```

## ðŸ”§ **HOOK REUSABILITY PATTERNS**

### **Pattern 7: Composable Hooks**

```typescript
// âœ… Base data fetching hook
const useApiCall = <T>(url: string, options?: RequestInit) => {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const execute = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await fetch(url, options);
      if (!response.ok) throw new Error(response.statusText);
      const result = await response.json();
      setData(result);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
    } finally {
      setLoading(false);
    }
  }, [url, options]);

  return { data, loading, error, execute };
};

// âœ… Specialized hooks that compose the base hook
export const useAirtableImages = () => {
  const { data, loading, error, execute } = useApiCall<AirtableResponse>('/api/airtable-images');
  
  useEffect(() => {
    execute();
  }, [execute]);

  return {
    images: data?.images || [],
    loading,
    error,
    refetch: execute,
  };
};

export const useTeamMembers = () => {
  const { data, loading, error, execute } = useApiCall<TeamMember[]>('/api/team');
  
  useEffect(() => {
    execute();
  }, [execute]);

  return {
    members: data || [],
    loading,
    error,
    refetch: execute,
  };
};

// âœ… UI state hooks
export const useToggle = (initialValue: boolean = false) => {
  const [value, setValue] = useState(initialValue);
  
  const toggle = useCallback(() => setValue(v => !v), []);
  const setTrue = useCallback(() => setValue(true), []);
  const setFalse = useCallback(() => setValue(false), []);
  
  return { value, toggle, setTrue, setFalse, setValue };
};

export const useLocalStorage = <T>(key: string, initialValue: T) => {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  });

  const setValue = (value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error('Error saving to localStorage:', error);
    }
  };

  return [storedValue, setValue] as const;
};
```

## ðŸ“Š **DATA MANAGEMENT PATTERNS**

### **Pattern 8: Context Providers for Shared State**

```typescript
// âœ… Generic context provider pattern
interface ProviderProps<T> {
  children: React.ReactNode;
  initialValue?: T;
}

const createContextProvider = <T extends Record<string, any>>(
  name: string,
  initialState: T,
  actions: Record<string, (state: T, payload?: any) => T>
) => {
  const Context = createContext<{
    state: T;
    dispatch: (action: { type: string; payload?: any }) => void;
  } | null>(null);

  const reducer = (state: T, action: { type: string; payload?: any }): T => {
    const actionFn = actions[action.type];
    return actionFn ? actionFn(state, action.payload) : state;
  };

  const Provider: React.FC<ProviderProps<T>> = ({ 
    children, 
    initialValue = initialState 
  }) => {
    const [state, dispatch] = useReducer(reducer, initialValue);
    
    return (
      <Context.Provider value={{ state, dispatch }}>
        {children}
      </Context.Provider>
    );
  };

  const useContext = () => {
    const context = React.useContext(Context);
    if (!context) {
      throw new Error(`use${name} must be used within ${name}Provider`);
    }
    return context;
  };

  return { Provider, useContext, Context };
};

// âœ… Calculator state management
interface CalculatorState {
  currentStep: number;
  selections: {
    ivc: string;
    hepatic: string;
    portal: string;
    renal: string;
  };
  images: {
    hepatic?: File;
    portal?: File;
    renal?: File;
  };
  predictions: {
    hepatic?: PredictionResult[];
    portal?: PredictionResult[];
    renal?: PredictionResult[];
  };
  vexusScore: number;
}

const calculatorActions = {
  setStep: (state: CalculatorState, step: number) => ({
    ...state,
    currentStep: step,
  }),
  
  setSelection: (state: CalculatorState, payload: { type: string; value: string }) => ({
    ...state,
    selections: {
      ...state.selections,
      [payload.type]: payload.value,
    },
  }),
  
  setImage: (state: CalculatorState, payload: { type: string; file: File }) => ({
    ...state,
    images: {
      ...state.images,
      [payload.type]: payload.file,
    },
  }),
  
  setPredictions: (state: CalculatorState, payload: { type: string; results: PredictionResult[] }) => ({
    ...state,
    predictions: {
      ...state.predictions,
      [payload.type]: payload.results,
    },
  }),
  
  calculateScore: (state: CalculatorState) => ({
    ...state,
    vexusScore: calculateVexusScore(state.selections),
  }),
  
  reset: () => calculatorInitialState,
};

const calculatorInitialState: CalculatorState = {
  currentStep: 0,
  selections: { ivc: '', hepatic: '', portal: '', renal: '' },
  images: {},
  predictions: {},
  vexusScore: 0,
};

export const {
  Provider: CalculatorProvider,
  useContext: useCalculator,
} = createContextProvider('Calculator', calculatorInitialState, calculatorActions);

// Usage in app:
const App = () => (
  <CalculatorProvider>
    <CalculatorPage />
  </CalculatorProvider>
);

// Usage in components:
const CalculatorStep = () => {
  const { state, dispatch } = useCalculator();
  
  const handleSelection = (type: string, value: string) => {
    dispatch({ type: 'setSelection', payload: { type, value } });
  };

  return (
    <div>
      <p>Current step: {state.currentStep}</p>
      <p>VEXUS Score: {state.vexusScore}</p>
    </div>
  );
};
```

## ðŸ§ª **TESTING REUSABLE COMPONENTS**

### **Pattern 9: Component Testing Utilities**

```typescript
// src/utils/testUtils.tsx
import { render, RenderOptions } from '@testing-library/react';
import { ThemeProvider } from '@mui/material';
import { vexusTheme } from '@/theme';

interface CustomRenderOptions extends Omit<RenderOptions, 'wrapper'> {
  theme?: typeof vexusTheme;
  initialState?: any;
}

const AllTheProviders: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  return (
    <ThemeProvider theme={vexusTheme}>
      {children}
    </ThemeProvider>
  );
};

const customRender = (
  ui: React.ReactElement,
  options?: CustomRenderOptions
) => render(ui, { wrapper: AllTheProviders, ...options });

export * from '@testing-library/react';
export { customRender as render };

// Component test utilities
export const createMockProps = <T extends Record<string, any>>(
  overrides: Partial<T> = {}
): T => ({
  ...defaultProps,
  ...overrides,
} as T);

export const mockImage = (width = 100, height = 100) => {
  return new File([new Blob()], 'test-image.jpg', { type: 'image/jpeg' });
};
```

This comprehensive approach ensures maximum code reusability and minimal duplication across your React + MUI project! ðŸš€
